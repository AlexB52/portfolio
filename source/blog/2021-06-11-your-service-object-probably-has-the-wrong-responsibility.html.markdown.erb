---

title: "Serializers - alternatives to service objects"
priority_title: "Service object alternatives: Serializers"
date: 2021-06-11 01:28 UTC
tags: rails,service objects,single responsibility
description: How to improve a specific type of service object and, who knows, get rid of it completely.

---

{::options parse_block_html="true" /}

<small style="float:right;"> _11 June 2021_ </small>


<h2 style="color:red;">This article is currently being rewritten. It addresses the wrong problem and people find it confusing. Sorry :(</h2>

# <%= title(current_article) %>

<div class="hero">
  ![publication feature](2021-06-11-your-service-object-probably-has-the-wrong-responsibility/be-the-change.jpg)
  <small class="d-block text-center">
    <span>
      Photo by <a href="https://unsplash.com/@brett_jordan?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Brett Jordan</a> on <a href="https://unsplash.com/s/photos/responsibility?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>  
    </span>
  </small>
</div>

I often come across service object classes like `CreatePurchase` or `PostCustomerReceipt` which create a record on the database and/or perform an HTTP query to a third party. Often that class has a `#call` method that does two things:

* generates a hash of values
* uses the ruby hash to create a record or perform a query

_**Disclaimer**: I usually explain my points with working code or something close to reality; however, today I'll use imaginary ruby code._

Services I described are used in these situations:

~~~ruby
def query
  case customer.colour
  when 'yellow' 
    QueryYellowCustomer.call(
      customer: customer,
      services: customer.services
    )
  when 'red' 
    QueryRedCustomer.call(
      customer: customer,
      bills: customer.bills
    )
  when 'blue' 
    QueryBlueCustomer.call(
      customer: customer
    )
  end
end
~~~
{: data-target="code-highlighter.ruby"}

## Why do I try to avoid this?

### Too much knowledge

The class in which `#query` is defined knows way too much about the customer, and the way to perform the query action.

### Focus: the attention is on the wrong part of the code

While the service is about acting, it is likely that another class already has this responsibility. What is important is how the hash is generated. Those services put the focus on an unimportant part of the code... the action. The parameters used to act is probably what requires more attention.

> **Often the #call method is identical between service objects and the only difference lies in how the hash is generated...**

Those classes often look something like this:

~~~ruby
class QueryYellowCustomer < QueryCustomer
  def self.call(**args)
    new(**args).call
  end

  def initialize(customer:, bills:)
    @customer = customer
    @bills = bills
  end

  def call
    return false unless valid?

    if Client.query(url, params: params) # or Customer.create(params)
      # something to return
    else
      # store errors with custom error handling
    end
  end

  private

  def valid?
    # rolls custom validations
  end

  def params
    result = {
      details1: details1,
      details2: details2,
      # ...
      detailsn: detailsn,
    }

    result.merge(more_details) if @customer.more_bill_details?
    result
  end

  def details1
    # a lot of stuff 
    #...
  end
  
  def details2
    # a lot of stuff 
    #...
  end
  
  # More details definition ...  

  def detailsn
    # a lot of stuff 
    #...
  end

  def more_details
    # conditional stuff
  end
end
~~~
{: data-target="code-highlighter.ruby"}

**The class handles errors, validations, query and generates the payload. Most of the methods are private and used to generate the hash. It looks noisy and hard to understand.**

### Testing

Because it is advised to only test public interfaces, the `#call` method is the only one getting tested. The tests often stub clients and put expectation on the parameters passed. Sometimes private methods end up getting tested too... ðŸ™ˆ

Something like this:

~~~ruby
require 'rails_helper'

RSpec.describe QueryYellowCustomer do
  let(:customer) { create(:customer, :important_trait) }
  let(:service) { described_class.new(customer:customer, bills: customer.bills) }

  describe '#call' do
    subject { service.call }

    it 'calls the client with the correct payload' do
      payload = service.send(:payload) # or hardcoded
      
      expect(Client).to receive(:query)
        .with('/url', payload)
        .and_return({hello: 'world'})
      
      subject
    end
  end

  describe '#payload' do
    subject { service.send(:payload) } # :see_no_evil:
    # ...
  end
end
~~~
{: data-target="code-highlighter.ruby"}

This can get frustrating when validations need tests too.

## Why extract the logic out of the service?

If you have made it this far, you can start to see where I'm going. Our service class does too much and we'll probably win by moving the hash generation logic into its class. **Who knows we might even get rid of the service entirely (hooray!).**

Let's consider a class whose responsibility is to provide the correct ruby hash to a service object, an active record or an HTTP client like so:

~~~ruby
# with a service object
def query
  QueryCustomer.call payload: CustomerPayload.to_h(customer)
end

# without the service object
def query
  Client.query url, params: CustomerPayload.to_h(customer)
end

# another form using ActiveRecord methods instead of a service
def query
  Customer.create CustomerPayload.to_h(customer)
end
~~~
{: data-target="code-highlighter.ruby"}

### Easier to understand

The `#query` method is way simpler and easier to read. The class in which `#query` is defined doesn't need to know anything about the customer, its colour and the different classes to call. It orchestrates the action by trusting `CustomerPayload` to return the correct hash.

### The factory

We can have a factory that chooses the appropriate class to generate the payload and return it to the service object.

~~~ruby
class CustomerPayload
  def self.to_h(customer)
    case customer.colour
    when 'yellow' then YellowPayload
    when 'red'    then RedPayload
    when 'blue'   then BluePayload
    else               Payload
    end.to_h(customer: customer)
  end

  class Payload
    # generate the ruby hash
  end

  class YellowPayload
    # generate the ruby hash
  end

  class RedPayload
    # generate the ruby hash
  end

  class BluePayload
    # generate the ruby hash
  end
end

~~~
{: data-target="code-highlighter.ruby"}

_You can have a factory that uses the correct service object instead but remember those generally have the same `#call` method and use a different generated hash._


### Testing

Each `Payload.to_h` method can be tested separately which is easier to understand. The tests will document how each hash is supposed to look based on contexts.

~~~ruby
require 'rails_helper'

RSpec.describe YellowPayload do
  describe '.to_h' do
    let(:bills) { [build(:bill)] }
    let(:customer) { create(:customer, :important_trait, bills: bills) }

    subject { described_class.to_h(customer: customer) }

    it { is_expected.to eql({}) # hardcoded hash }

    context 'when bills are important' do
      let(:bills) { [build(:bill, :important)] }

      it { is_expected.to eql({}) # another hardcoded hash }
    end
  end
end
~~~
{: data-target="code-highlighter.ruby"}

## Conclusion 

This is a fictive example but if you use service objects you've likely encountered some similar use cases. Service objects are overused and this type of refactoring can potentially remove the need for these types entirely. Future devs will thank you for it.

### Pushing it further

Other steps to improve the code would be to:

* rename `Payload` classes with something closer to the domain you are coding for.
* include `ActiveModel::Serialization` to generate the hash elegantly.
* include `ActiveModel::Validations` for a validation framework.
* include `ActiveModel::Model` for maximum brownie points.

### Read more about service objects

<% article = blog.articles.find { |article| article.title == "An Alternative to Service Objects" } %>
I've written another article about service objects if you're interested: <%= link_to article.title, article.url %>.
